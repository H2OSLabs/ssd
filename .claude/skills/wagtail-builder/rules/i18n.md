# Wagtail Internationalization (i18n) with Wagtail Localize

## Overview

Wagtail 7.x + wagtail-localize 提供完整的多语言内容管理解决方案。

**Key Principle**: Pages 自动支持，Snippets/Settings 需要 TranslatableMixin。

---

## Configuration Checklist

### 1. Installation

```bash
# pyproject.toml
dependencies = [
    "wagtail>=7.2",
    "wagtail-localize>=1.10",
    "polib>=1.2.0",
]
```

### 2. INSTALLED_APPS

**CRITICAL**: `wagtail_localize` 必须在 `wagtail.contrib.settings` 之前：

```python
INSTALLED_APPS = [
    # Your apps
    "myapp",

    # Wagtail Localize - MUST be before wagtail.contrib.settings
    "wagtail_localize",
    "wagtail_localize.locales",

    "wagtail.contrib.settings",  # AFTER wagtail_localize
    # ... other wagtail apps
]
```

**Why?** wagtail_localize.locales 临时替换 Wagtail 内置的 locales 模块以支持翻译。

### 3. Settings Configuration

```python
# Internationalization
LANGUAGE_CODE = "en"  # Default language

LANGUAGES = [
    ("en", "English"),
    ("zh-hans", "简体中文"),
    ("fr", "Français"),
]

# Wagtail i18n
WAGTAIL_I18N_ENABLED = True
WAGTAIL_CONTENT_LANGUAGES = LANGUAGES

# Django i18n
USE_I18N = True
USE_TZ = True

# Locale paths for Django UI translations (optional)
LOCALE_PATHS = [
    os.path.join(BASE_DIR, "locale"),
]
```

### 4. Middleware Configuration

**CRITICAL**: `LocaleMiddleware` 必须在 `RedirectMiddleware` 之前：

```python
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.locale.LocaleMiddleware",  # HERE
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "wagtail.contrib.redirects.middleware.RedirectMiddleware",  # AFTER LocaleMiddleware
]
```

**Why?** LocaleMiddleware 需要在 URL 解析之前激活语言。

### 5. URL Configuration

```python
from django.conf.urls.i18n import i18n_patterns

# URLs without language prefix (admin, API, static)
urlpatterns = [
    path("django-admin/", admin.site.urls),
    path("admin/", include(wagtailadmin_urls)),
    path("documents/", include(wagtaildocs_urls)),
    path("api/v2/", api_router.urls),
]

# URLs with language prefix (public pages)
urlpatterns += i18n_patterns(
    path("search/", search_views.search, name="search"),
    path("", include(wagtail_urls)),
    prefix_default_language=True,  # /en/ and /zh-hans/
)
```

**Result**:
- Admin: `/admin/` (no prefix)
- API: `/api/v2/` (no prefix)
- English pages: `/en/`, `/en/blog/`
- Chinese pages: `/zh-hans/`, `/zh-hans/blog/`

### 6. Database Setup

```bash
# Run migrations
python manage.py migrate

# Create locales via Django shell
python manage.py shell
>>> from wagtail.models import Locale
>>> Locale.objects.create(language_code='en')
>>> Locale.objects.create(language_code='zh-hans')
```

**OR** create via Wagtail admin: Settings → Locales → Add locale

---

## Model Patterns

### Pattern 1: Pages (Automatic i18n)

**Pages 自动支持翻译**，无需任何修改：

```python
from wagtail.models import Page
from wagtail.fields import RichTextField

class BlogPage(Page):
    body = RichTextField()
    author = models.ForeignKey('Author', on_delete=models.PROTECT)

    # No TranslatableMixin needed!
    # Page already has locale and translation_key
```

**Workflow**:
1. Create page in English (`/en/blog/`)
2. Click "..." menu → "Translate"
3. Select target locale (Chinese)
4. Edit Chinese version
5. Publish → available at `/zh-hans/blog/`

### Pattern 2: Snippets (Requires TranslatableMixin)

**Snippets 需要 TranslatableMixin** 才能翻译：

```python
from django.db import models
from wagtail.models import TranslatableMixin
from wagtail.snippets.models import register_snippet

@register_snippet
class Author(TranslatableMixin, models.Model):
    name = models.CharField(max_length=255)
    bio = models.TextField()

    class Meta:
        unique_together = [("translation_key", "locale")]

    def __str__(self):
        return self.name
```

**CRITICAL**:
- ✅ `TranslatableMixin` first in inheritance
- ✅ `unique_together` constraint required
- ✅ Adds `locale` and `translation_key` fields automatically

### Pattern 3: Settings (Requires TranslatableMixin)

**Site Settings 同样需要 TranslatableMixin**：

```python
from wagtail.contrib.settings.models import BaseSiteSetting, register_setting
from wagtail.models import TranslatableMixin

@register_setting
class SocialMediaSettings(TranslatableMixin, BaseSiteSetting):
    twitter_handle = models.CharField(max_length=255, blank=True)
    default_sharing_text = models.CharField(max_length=255, blank=True)

    class Meta:
        unique_together = [("translation_key", "locale")]
```

**Use case**: Different social handles or text per language.

---

## Migration Strategy for Existing Data

### Problem

Adding `locale` and `translation_key` to existing models with data causes:
```
IntegrityError: NOT NULL constraint failed
```

### Solution: Three-Step Migration

**Step 1: Add nullable fields**

```python
migrations.AddField(
    model_name='author',
    name='locale',
    field=models.ForeignKey(
        null=True,  # Nullable initially
        on_delete=django.db.models.deletion.PROTECT,
        to='wagtailcore.locale',
    ),
)
```

**Step 2: Populate with data migration**

```python
def populate_locale_and_translation_key(apps, schema_editor):
    Locale = apps.get_model('wagtailcore', 'Locale')
    Author = apps.get_model('myapp', 'Author')

    en_locale = Locale.objects.get(language_code='en')

    for author in Author.objects.all():
        author.locale = en_locale
        author.translation_key = uuid.uuid4()
        author.save()

migrations.RunPython(populate_locale_and_translation_key)
```

**Step 3: Make fields non-nullable**

```python
migrations.AlterField(
    model_name='author',
    name='locale',
    field=models.ForeignKey(  # null=False now
        on_delete=django.db.models.deletion.PROTECT,
        to='wagtailcore.locale',
    ),
)

migrations.AlterUniqueTogether(
    name='author',
    unique_together={('translation_key', 'locale')},
)
```

### Management Command Template

```python
# myapp/management/commands/set_default_locale.py
from django.core.management.base import BaseCommand
from wagtail.models import Page, Locale

class Command(BaseCommand):
    help = 'Set default locale for existing pages'

    def handle(self, *args, **options):
        en_locale = Locale.objects.get(language_code='en')
        pages_updated = Page.objects.filter(
            locale__isnull=True
        ).update(locale=en_locale)

        self.stdout.write(
            self.style.SUCCESS(
                f'Updated {pages_updated} pages to English'
            )
        )
```

---

## API Configuration for i18n

### Serializer with Locale Fields

```python
from rest_framework import serializers
from wagtail.api.v2.serializers import PageSerializer

class ArticlePageSerializer(PageSerializer):
    # Locale information
    locale = serializers.CharField(
        read_only=True,
        source='locale.language_code'
    )

    # Available translations for language switcher
    available_translations = serializers.SerializerMethodField()

    def get_available_translations(self, obj):
        """Return available language versions."""
        return [
            {
                'locale': trans.locale.language_code,
                'title': trans.title,
                'url': trans.url,
            }
            for trans in obj.get_translations().live()
        ]
```

### API Usage

```bash
# Filter by locale
curl '/api/v2/pages/?locale=en&type=blog.BlogPage'
curl '/api/v2/pages/?locale=zh-hans&type=blog.BlogPage'

# Get translations
curl '/api/v2/pages/123/?fields=locale,available_translations'
```

**Response example**:
```json
{
  "id": 123,
  "title": "Hello World",
  "locale": "en",
  "available_translations": [
    {
      "locale": "en",
      "title": "Hello World",
      "url": "/en/blog/hello-world/"
    },
    {
      "locale": "zh-hans",
      "title": "你好世界",
      "url": "/zh-hans/blog/hello-world/"
    }
  ]
}
```

---

## Template Implementation

### Language Switcher

```django
{# templates/components/language_switcher.html #}
{% load wagtailcore_tags i18n %}

<nav class="language-switcher">
    {% get_available_languages as languages %}
    {% get_current_language as LANGUAGE_CODE %}

    {% for lang_code, lang_name in languages %}
        {% if page.locale.language_code == lang_code %}
            <span class="current">{{ lang_name }}</span>
        {% else %}
            {% with translation=page.get_translation|default:None %}
                {% if translation %}
                    <a href="{% pageurl translation %}">{{ lang_name }}</a>
                {% else %}
                    <span class="unavailable">{{ lang_name }}</span>
                {% endif %}
            {% endwith %}
        {% endif %}
    {% endfor %}
</nav>
```

### Locale-Aware Queries

```python
# In views or template tags
def get_latest_articles(request):
    current_locale = request.LANGUAGE_CODE

    return ArticlePage.objects.filter(
        locale__language_code=current_locale
    ).live().order_by('-publish_date')[:5]
```

---

## Common Mistakes & Solutions

### ❌ Mistake 1: Forgetting unique_together

```python
# ❌ Bad: Missing constraint
class Author(TranslatableMixin, models.Model):
    name = models.CharField(max_length=255)
    # Missing Meta!
```

**Result**: Can create duplicate translations in same locale.

```python
# ✅ Good: With constraint
class Author(TranslatableMixin, models.Model):
    name = models.CharField(max_length=255)

    class Meta:
        unique_together = [("translation_key", "locale")]
```

### ❌ Mistake 2: Wrong INSTALLED_APPS order

```python
# ❌ Bad: wagtail_localize after settings
INSTALLED_APPS = [
    "wagtail.contrib.settings",
    "wagtail_localize",  # TOO LATE!
]
```

**Result**: Settings translation doesn't work.

```python
# ✅ Good: Correct order
INSTALLED_APPS = [
    "wagtail_localize",
    "wagtail_localize.locales",
    "wagtail.contrib.settings",
]
```

### ❌ Mistake 3: LocaleMiddleware position

```python
# ❌ Bad: After CommonMiddleware
MIDDLEWARE = [
    "django.middleware.common.CommonMiddleware",
    "django.middleware.locale.LocaleMiddleware",  # TOO LATE!
]
```

**Result**: Language prefix in URLs doesn't work correctly.

```python
# ✅ Good: Before CommonMiddleware
MIDDLEWARE = [
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.locale.LocaleMiddleware",
    "django.middleware.common.CommonMiddleware",
]
```

### ❌ Mistake 4: Using TranslatableMixin on Pages

```python
# ❌ Bad: Unnecessary mixin
class BlogPage(TranslatableMixin, Page):  # DON'T DO THIS!
    body = RichTextField()
```

**Result**: Migration conflicts, Page already has locale support.

```python
# ✅ Good: Page only
class BlogPage(Page):
    body = RichTextField()
```

---

## Testing i18n Implementation

### Unit Tests

```python
from django.test import TestCase
from wagtail.models import Locale, Page

class LocalizationTestCase(TestCase):
    def setUp(self):
        self.en = Locale.objects.get(language_code='en')
        self.zh = Locale.objects.get(language_code='zh-hans')

    def test_page_translation(self):
        """Test page can be translated."""
        # Create English page
        page_en = BlogPage(
            title="Hello",
            slug="hello",
            locale=self.en,
        )
        root = Page.objects.get(depth=1)
        root.add_child(instance=page_en)

        # Create Chinese translation
        page_zh = page_en.copy_for_translation(self.zh)
        page_zh.title = "你好"
        page_zh.save()

        # Verify
        self.assertEqual(page_zh.locale, self.zh)
        self.assertEqual(
            page_zh.translation_key,
            page_en.translation_key
        )
        self.assertTrue(page_en.has_translation(self.zh))

    def test_snippet_translation(self):
        """Test snippet translation."""
        author_en = Author.objects.create(
            name="John",
            locale=self.en,
        )

        author_zh = author_en.copy_for_translation(self.zh)
        author_zh.name = "约翰"
        author_zh.save()

        self.assertEqual(author_zh.locale, self.zh)
        self.assertTrue(author_en.has_translation(self.zh))
```

### Integration Tests

```python
def test_url_routing(self):
    """Test language-prefixed URLs work."""
    # English
    response = self.client.get('/en/')
    self.assertEqual(response.status_code, 200)

    # Chinese
    response = self.client.get('/zh-hans/')
    self.assertEqual(response.status_code, 200)

def test_api_locale_filter(self):
    """Test API locale filtering."""
    response = self.client.get('/api/v2/pages/?locale=en')
    data = response.json()

    for page in data['items']:
        self.assertEqual(page['locale'], 'en')
```

---

## Field-Level Configuration

### Translatable vs Synchronized Fields

By default, Wagtail Localize auto-detects:
- **Translatable**: Text fields (CharField, TextField, RichTextField)
- **Synchronized**: Foreign keys, images, dates

**Override with `override_translatable_fields`**:

```python
class BlogPage(Page):
    title = models.CharField(max_length=255)
    author = models.ForeignKey('Author', on_delete=models.PROTECT)
    cover_image = models.ForeignKey('wagtailimages.Image', ...)
    publish_date = models.DateField()

    # Override: Make author translatable instead of synchronized
    override_translatable_fields = [
        TranslatableField("author"),
    ]
```

**Complete customization with `translatable_fields`**:

```python
from wagtail_localize.fields import TranslatableField, SynchronizedField

class BlogPage(Page):
    translatable_fields = [
        TranslatableField("title"),
        TranslatableField("body"),
        SynchronizedField("author"),  # Never translate
        SynchronizedField("publish_date"),
    ]
```

---

## When to Use Wagtail Localize

### ✅ Use When:

- Multiple language versions of content
- Translators need dedicated workflow (submit/review)
- Content synchronization across locales (images, structure)
- Translation memory/reuse needed
- Professional translation services integration

### ❌ Don't Use When:

- Single language only
- Django's `gettext` sufficient for UI strings
- No content translation needed (only interface)

### Alternatives:

- **wagtail.contrib.simple_translation**: Simpler, no translation workflow
- **Django i18n** (`gettext`): For UI strings, not content

---

## Production Checklist

Before deploying i18n to production:

- [ ] All `INSTALLED_APPS` in correct order
- [ ] `LocaleMiddleware` before `CommonMiddleware`
- [ ] `i18n_patterns` configured for public URLs
- [ ] All Snippets/Settings have `TranslatableMixin`
- [ ] All translatable models have `unique_together`
- [ ] Existing data migrated with locale/translation_key
- [ ] Default locale set for all content
- [ ] API serializers include `locale` field
- [ ] Templates include language switcher
- [ ] Tests cover translation workflow
- [ ] URL routing tested for all locales
- [ ] Search configured for multi-locale queries

---

## Sources

Official documentation references:
- [Wagtail Localize Tutorial](https://wagtail-localize.org/stable/tutorial/)
- [Wagtail i18n Documentation](https://docs.wagtail.org/en/stable/advanced_topics/i18n.html)
- [Field Configuration](https://wagtail-localize.org/stable/how-to/field-configuration/)
- [ModelAdmin Translation](https://wagtail-localize.org/stable/how-to/modeladmin/)
